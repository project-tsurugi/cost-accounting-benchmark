Draft 2023-04-12

# 原価計算ベンチマーク

## 概要

実行時間の長いバッチ処理を実行し、その間に断続的にオンライン処理を実行する。
このようにする理由は、長いトランザクションと短いトランザクションが混じった状態を作るためである。

そして、バッチ処理の実行時間およびオンライン処理の処理数を測定する。

当ベンチマークの業務イメージは、パンを作る工場である。
バッチ処理では、パンを作る為に必要な原料の量と原価の計算を行う。
オンライン処理では、バッチ処理の入力となるテーブルの更新と、計算結果の照会等を行う。



## テーブル定義

- 工場マスター
  - PK：工場ID
  - カラム：工場名
- 品目マスター
  - 製造する製品やその原料
  - PK：品目ID、有効日付範囲(※1)
  - カラム：品目名
  - カラム：品目種類
    - 製品か、原料か
  - カラム：単位、重量比、重量単位
    - 当該品目の量を示す際の単位と、それを重量に変換する為の比率
  - カラム：品目単価、品目単価単位
- 品目構成マスター
  - 品目の原料となる品目（木構造）
  - PK：品目ID、親品目ID、有効日付範囲(※1)
  - カラム：原料単位、原料数量
    - 例：100グラムとか、10ミリリットルとか、1センチメートルとか、1個とか
    - 製品となる品目では、null
  - カラム：ロス率[％]
- 製造品目マスター
  - 製造する品目と、その生産量（個数）
  - PK：工場ID、品目ID、有効日付範囲(※1)
    - 品目は、製品となる品目のみ
  - カラム：生産数（1日分）
- 原価マスター
  - 品目（原料）の原価
    - 在庫量と金額から単位当たりの原価を算出する
  - PK：工場ID、品目ID
  - カラム：在庫単位、在庫数量（1日分）、在庫金額（1日分）
- 在庫テーブル
  - 原価マスターから工場毎の在庫金額を集計して保持する
  - PK：日付、工場ID
  - カラム：在庫金額
- 度量衡マスター
  - 標準単位に変換するスケールを持つ
    - 例：5センチメートル × 0.01（スケール）→0.05メートル
  - PK：単位
  - カラム：単位名称
  - カラム：単位種類(※2)、標準単位(※3)、スケール
- 結果テーブル
  - 工場・品目毎の計算結果（木構造）
  - PK：工場ID、日付、製造品目ID、親品目ID、品目ID
    - 製造品目ID＝品目IDの場合、親品目IDは0
    - 製造品目毎の、親品目→品目の木構造（製造品目毎に、品目構成マスターで辿れる全品目を網羅する）
  - カラム：生産数
    - 生産数←製造品目の製造品目マスター.生産数
  - カラム：重量（品目当たり）、重量単位、重量計、重量計単位、重量割合
    - 重量←品目構成マスター.原料数量（原料単位種類が重量でない場合は品目マスター.重量比を使って重量に変換）
      - 原料数量＝nullの場合（主に製造品目の場合）は、0
    - 重量計←重量 + Σ子の品目の重量計
    - 重量割合[％]←重量計 ÷ 製造品目の重量計 × 100
  - カラム：標準量単位、標準量（品目当たり）
    - 標準量←品目構成マスター.原料数量 × 必要割合 × 親品目の必要割合…（親品目を再帰的に全て辿って乗算する）
      - 必要割合←100 ÷ (100 - 品目構成マスター.ロス率)
      - 原料数量＝nullの場合（主に製造品目の場合）は、0
  - カラム：所要量単位、所領量
    - 所要量←標準量 × 生産数
  - カラム：原価（品目当たり）、総原価、製造原価（品目当たり）、総製造原価
    - 総原価←(原価マスター.在庫金額 ÷ 原価マスター.在庫数量) × 所要量
    - 原価←総原価 ÷ 生産数
    - 総製造原価←総原価 + Σ子の品目の総製造原価
    - 製造原価←総製造原価 ÷ 生産数



※1: 有効日付範囲は、開始日と終了日を持つ。実際のDDLとしては、開始日のみをPKに含める。有効日付範囲以外のPKが同一のデータに対して、日付の範囲が重なることはない。特定の日付でSELECT（日付 between 開始日 and 終了日）すると、PKで一意になる。

※2: 単位種類＝｛ 重量, 容量, 長さ, 個数 ｝

※3: 標準単位は、重量＝グラム、容量＝ミリリットル、長さ＝メートル

計算の際に単位種類が異なる場合はエラーとする。（実際にはこのような状態は発生しない想定）
計算の際に単位が異なる場合は、度量衡マスターのスケールを使って値を変換して単位を統一する。
（度量衡マスターが取得できなかった場合はスケール＝1とする（単位種類＝個数の場合を想定））

上記のテーブルに計算用のカラムを追加するのは不可。
計算用の中間テーブルやビューを用意するのは可。
（マテリアライズドビューやトリガーを使う場合は、そのリフレッシュや実行はバッチ実行期間内に行うこと）



### カラム定義（データ型）

- unique ID
  - 工場IDや品目ID等のID
  - 整数（4バイト）
- 日付
  - 開始日・終了日等
  - RDBMSのdate型
- name
  - 工場名等の名称
  - variable text（可変長文字列。桁数はカラムの種類に応じて決める）
- 比率、金額
  - unsigned numeric（固定小数。桁数や精度はカラムの種類に応じて決める）



## バッチ処理

1. バッチ引数として、工場（複数指定可能とする）と日付を指定する。
   - 工場が指定されなかった場合は全工場を対象とする。

2. 指定された工場・日付の製造品目マスターの全品目を処理対象とする。
3. 処理対象の製造品目マスターの品目に対し、品目構成マスターを再帰的に走査し、原料となる子孫品目を全て取得する。（木構造データとなる）
4. 木構造データを元に計算（重量計算・所要量計算・原価計算）を行い、結果テーブルに出力する。
   - 対象工場を全てDELETEし、結果レコードをINSERTする。



### バッチ処理詳細

benchmark2-batch.md参照。



## オンライン処理

### マスター更新系

- 新規開発商品の追加
  - 品目マスターのINSERTおよび品目構成マスターのINSERT
  - 品目マスター・品目構成マスターの登録で1トランザクション。その後、生産数の登録を行う
- 生産数の変更
  - 製造品目マスターのUPDATEまたはINSERT
- 原材料の変更
  - 品目構成マスターのDELETEまたはINSERT
- 原価の変更（在庫増加・在庫減少）
  - 原価マスターのSELECT（FOR UPDATE）およびUPDATE
- 在庫の更新
  - 原価マスターのSELECTおよび在庫テーブルへのDELETE・INSERT
    - バッチ処理と無関係なテーブルを更新するパターン。



### 照会系

- 重量の照会
  - 結果テーブルから、日付と品目（製品）を指定して、重量をSELECT
    - 品目の重量は工場が異なっても同じ値のはずなので、適当に1工場だけ選択する。
- 所要量の照会
  - 結果テーブルから、工場と日付を指定して、品目（材料）毎の所要量（sum）をSELECT
- 原価の照会
  - 結果テーブルから、工場と日付を指定して、品目（製品）毎の原価をSELECT



### オンライン処理詳細

benchmark3-online.mdを参照。



## 実行方法

### 測定環境

- 測定対象のDBを構成するDBサーバー

- バッチ処理を実行するバッチサーバー
- オンライン処理を実行するオンラインサーバー

それぞれのサーバーは、実装に応じて、実体が複数のサーバーマシンでもよい。


### 実行方法

バッチ処理はバッチサーバーから実行する。
実行時間は30分～3時間程度の想定。
バッチ処理は1つしか実行しない。（1回の測定で複数のバッチ処理を実行することはない）



オンライン処理はオンラインサーバーからバッチ処理の実行中に実行する。
オンライン処理は多重で実行することがありうる。

オンライン処理は複数クライアント（スレッド）を想定し、クライアント毎にランダムな間隔を空けて連続して実行する。



バッチ処理とオンライン処理を同時に実行するのは、長いトランザクションと短いトランザクションが重なることを目的としている。
本来ならば、対象データ（製造する品目）が同一のトランザクションでないと、重なることにならない。
しかし、バッチ処理内のどのタイミングでどの品目が処理されるかは実装依存であり、外部からそのタイミングを見計らってオンライン処理を実行することは困難である。
そのため、データの重なりについては規定しない。

同様に、業務的には生産数の変更や原材料の変更などの更新処理が頻繁に行われるとは考えにくいが、長いトランザクションと短いトランザクションを重ねるためにベンチマーク用の処理として大量に実行する。



### 実行パターン

バッチ処理は正常系パターンと異常系パターンの2種類実行し、それぞれ別個に計測する。

正常系パターンは、処理が正常に終わったらコミットする。（普通のパターン）

異常系パターンは、実際の処理が正常に終わっても、異常が起きたと見做し、失敗扱いとしてロールバックさせる。このパターンは、ロールバックの性能を測定するためのものである。

どちらのパターンで実行するかは、バッチの引数によって切り替える想定。
各トランザクションに対し、この引数が100（デフォルト）の場合は常にコミットする。0の場合は常にロールバックする。（この値は処理が成功する確率を意味する。1～99の場合は、各処理がその確率でコミットする）
（もしバッチの実装が全件一括コミットになっているなら、全件コミットか全件ロールバックのいずれかになる）

1トランザクション内で複数の製造品目をまとめて処理する実装になっている場合、トランザクションの最初の品目で失敗扱いとなっても、残りの他の品目は処理するものとする。（残りの品目を処理した後でロールバックする）
残りの品目を処理しないと、その分実行時間が短くなってしまうため。
（このため、処理失敗と見做す判定は、トランザクションの終了直前に行う想定）



## 計測

バッチ処理の実行時間を測定する。
スループット = 処理品目数 ÷ バッチ実行時間
処理品目数は、コミットした数とロールバックした数、およびその合計。

オンライン処理の実行回数を測定する。
スループット = オンライン処理数 ÷ バッチ実行時間




## データ

度量衡マスターのデータは、固定値なので、別表の通りとする。

それ以外のデータは、ロジックに基づいて生成する。（件数を変化させられるようにするため）

スケーリング対象として、工場数、品目数（製造品目、中間品目、原材料品目それぞれ）、製造品目数を指定する。
スケーリングの目的は、「小規模なDBを小型サーバー（1socket）で実行する」「大規模なDBを数百コアのサーバーマシンで実行する」のどちらでも使えるようにする為。



### 初期データ作成方法詳細

benchmark4-data.mdを参照。


