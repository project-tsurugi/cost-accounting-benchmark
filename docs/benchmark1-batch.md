Draft 2020/11/9

- 以下、SQL形式で処理を記述しているが、同等の処理であれば、そのSQLそのものである必要は無い。（テーブルの結合方法や処理順序なども実装により自由）

### バッチ処理詳細

1. バッチ引数として、工場（複数指定可能とする）と日付を指定する。

   - 工場が指定されなかった場合は全工場を対象とする。

2. 結果テーブルから対象工場を全て削除する。
    `delete from 結果テーブル where 工場ID in (バッチ引数の工場) and 日付=バッチ引数の日付`

    - バッチ引数で工場が指定されなかった場合は、工場IDの条件を外す。もしくは工場マスターの全工場IDを指定する。
    - ★MEMO 初期データ作成直後は結果テーブルは空で、2回目以降はデータが有る状態からのdeleteなので、状態が異なる。ベンチマーク測定時に考慮する必要あり

3. 製造品目マスターから指定された工場・日付の全品目を取得する。取得された品目が処理対象となる。

   `select * from 製造品目マスター where 工場ID in (バッチ引数の工場) and バッチ引数の日付 between 開始日 and 終了日`

   - バッチ引数で工場が指定されなかった場合は、工場IDの条件を外す。もしくは工場マスターの全工場IDを指定する。
   - 製造品目マスター.生産数＝0の場合は、以降の処理を行わない。

4. 処理対象品目に対し、品目構成マスターを再帰的に走査し、原料となる子孫品目を全て取得する。（木構造データとなる）

   1. `select * from 品目構成マスター where 親品目ID=処理対象品目 and バッチ引数の日付 between 開始日 and 終了日 `

   2. 1で取得した品目IDを処理対象品目とし、1を繰り返す。

   ※再帰ビューが使えるなら、それでも可。

5. 木構造データを元に各種計算を行う。

   1. 品目構成の木構造の全要素に対し重量計算を行う。
      1. 品目構成マスター.原料数量＝nullの場合
         - 重量←0
         - 重量単位←ミリグラム
      2. 品目構成マスター.原料数量≠nullの場合
         1. 品目構成マスター.原料単位を元に度量衡マスターを取得する。
         2. 度量衡マスター単位種類＝重量の場合
            - 重量←品目構成マスター.原料数量
            - 重量単位←品目構成マスター.原料単位
         3. 度量衡マスター単位種類≠重量の場合
            1. 品目構成マスター.原料数量を、品目構成マスター.原料単位から品目マスター.単位に合うよう変換する。
            2. 重量←変換後数量×品目マスター.重量比
               重量単位←品目マスター.重量単位
      3. 重量計←重量 + Σ子品目の重量計（単位を共通なものに統一して計算する）
         重量計単位←重量および子品目の重量計の統一された単位
      4. 全木構造の重量計が決まった後で、各要素の重量割合を計算する。
         重量割合[％]←重量計 ÷ 製造品目（ルート要素）の重量計 × 100（単位を共通なものに統一して計算する）
         - 重量計が0の場合は重量割合も0とする。
   2. 品目構成の木構造の全要素に対し所要量計算を行う。
      1. 品目構成マスター.原料数量＝nullの場合
         - 標準量←0
         - 標準量単位←品目マスター.単位
      2. 品目構成マスター.原料数量≠nullの場合
         - 標準量←品目構成マスター.原料数量 × 必要割合 × 親品目の必要割合…（親品目を再帰的に全て辿って乗算する）
           - 必要割合←100 ÷ (100 - 品目構成マスター.ロス率)
         - 標準量単位←品目構成マスター.原料単位
      3. 所要量を決定する。
         - 所要量単位←標準量単位が容量系の場合はL、重量系の場合はkg、それ以外は標準量単位と同じ
         - 所要量←標準量 × 製造品目マスター.生産数（標準量単位から所要量単位に変換）
   3. 品目構成の木構造の全要素に対し原価計算を行う。
      1. 原価マスターを取得する。
         `select * from 原価マスター where 工場ID=処理対象工場 and 品目ID=処理対象品目`
      2. 原価マスターが取得できた場合
         - 総原価←(原価マスター.在庫金額 ÷ 原価マスター.在庫数量) × 所要量（単位を共通なものに統一して計算する）
      3. 原価マスターが取得できなかった場合
         1. 品目マスターを取得する。
            `select * from 品目マスター where 品目ID=処理対象品目 and バッチ引数の日付 between 開始日 and 終了日 `
            必ず取得できるはずなので、取得できなかったらエラー。
         2. 総原価←品目マスター.品目単価×所要量（単位を共通なものに統一して計算する）
            - 品目単価がnullの場合は総原価を0とする
      4. 原価←総原価 ÷ 製造品目マスター.生産数
      5. 総原価計←総原価 + Σ子品目の総原価計
      6. 原価計←総原価計 ÷ 製造品目マスター.生産数

6. 結果テーブルに出力する。

   1. 品目構成の木構造の全要素を結果テーブルにINSERTする。
      `insert into 結果テーブル values(処理対象工場ID, バッチ日付, 製造品目マスター.品目ID, 木構造.品目ID, …)`
      - プライマリキーが重複する場合は、各項目の値を合算して、1レコードにしてINSERTする。



結果がこのようになっていればよく、テーブルの取得方法（結合順序）や処理方法（並列処理・直列処理）は実装の任意。

コミットタイミング（コミット単位）も実装の任意だが、最低限、1つの製造品目（製造品目マスターから取得した品目ID）（それを構成する複数の品目）に対しては1トランザクションとする。（複数の製造品目で1トランザクションとするのは可）

