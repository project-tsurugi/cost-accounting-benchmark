
■PL/SQLのコーディング上の注意点

●関数の引数・戻り値の型のvarchar2
create tableだと「varchar2(10)」のように桁数を指定する必要があるが、
関数の引数・戻り値の型で桁数を指定するとエラーになる。「varchar2」と記述する。

●PL/SQLの型とSQLの型が異なる場合
PL/SQLにはboolean型があるがOracleのSQLには無いので、関数の引数や戻り値の型にbooleanを指定するとSQLから呼び出せない。
同様に、ユーザー定義型（type）が引数や戻り値の型にある関数もSQLから呼び出せない。

※そういう関数をSQLから呼び出してテストすることが出来ない。

●テーブルのレコード型
変数宣言でテーブルのレコード型を指定する際に、
（PL/pgSQLだとテーブル名のみでも構わないが）
PL/SQLでは「%rowtype」が必須。

●レコード型やユーザー定義型の変数の使用
「%rowtype」で定義した変数やtypeで作られたユーザー定義型の変数は、
・直接ログ出力できない。（文字列へ変換できない）
・「||」で文字列結合できない。
・is nullでチェックできない。「変数.フィールド is null」は可。
（PL/pgSQLではいずれも出来た）

・nullを代入することは出来る。

●select * intoで0件の場合の処理
「select * into 変数」で、select結果が0件の場合、
（PL/pgSQLでは変数にnullが入ったが）
PL/SQLでは例外が発生する。

begin
  select * into 変数 from テーブル;
exception
  when NO_DATA_FOUND then
    変数 := null;
end;

●例外メッセージが書けない
raise文で自由なメッセージを書けない。（ユーザー定義の例外を作ることは出来る）
（PL/pgSQLではraise文でメッセージを記述できる。新しい例外を作ることは出来ない）

●代入演算子
代入は「:=」のみ。
（PL/pgSQLでは「=」も可）

●パッケージの関数・プロシージャーをimportする機能が無い
外部のパッケージの関数やプロシージャーを呼ぶ場合は、常にパッケージ名で修飾する必要がある。

●使用できないキーワード
ユーザー定義型（record）のカラム名にindexという名前が使えない。
（PL/pgSQLのcreate typeでは使える）

●配列
PL/SQLでは「type int_array varray(100) of int」のようにユーザー定義型として定義し、上限を指定する必要がある。
変数宣言で直接「ns varray(100) of int」と書くことは出来ない。

「type int_array table of int」であれば、上限を指定する必要は無い（typeで定義する必要はある）。

（PL/pgSQLでは「ns int[]」のように変数宣言する。上限の指定は不要で、自由に拡張できる）


